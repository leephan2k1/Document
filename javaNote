Primitive data type:
+byte [8bit] -128 -> 127;
+short [16bit] -32768 -> 32767;
+int [32bit] -2^31 -> 2^31 -1;
+long [64bit] -2^63 -> 2^63 -1;
	//Vượt ra phạm vi của int nên khai báo: long ex = 214748212L;
+double [64bit] EX: double a=3.2;
+float [32bit] EX: float a = 3.2f;
+char [16bit] unicode

FOR-EACH
	for(int elements: arr){
		//code
	}
LABEL BREAK
	label:
		for(expression1){
			// code
			for(expression2){
				if(codition) break label;
			}
		}
		// code

CONSTRUCTOR (Có 3 kiểu)
	// Constructor không thể là một abstract, static hoặc final.
	// Constructor có thể overload nhưng không thể override.
	+ Constructor không có đối số
		private Constructor() {
   		// body of constructor
		}
	+ Constructor Default
		Nếu không có Constructor ko đối số nào được tạo, trình biên dịch tự khởi tạo Constructor làm nhiệm vụ khởi tạo các biến thực thể với giá trị mặc định.
		=> https://ibb.co/8jgcrVT
	+ Constructor Parameterized (Tham số hoá)
		Constructor overloading: https://ibb.co/42h4yQ8
2 Quy tắc để khởi tạo 1 Constructor:
	+ Cùng tên với tên Class.
	+ Không có kiểu trả về.
	
STRING
	//String là một lớp trong Java, khác với primitive type (long, int, short, byte, double, char,...)
	+ Một số phương thức trong lớp String: https://ibb.co/pxf3Vpq
	+ Document từ Oracle: https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?fbclid=IwAR2JwZ4AJ6JGcvuSeaablfqq-cUDahBhqRM8peIcHj9Qgl7VmNYULMyVn1U
ACCESS MODIFIER 
	https://www.w3schools.com/java/java_modifiers.asp
	+ abstract (Đối với class): Khi khởi tạo 1 abstract class, thì k thể khởi tạo đối tượng từ class mà chỉ có thể kế thừa.
	(Có 4 kiểu AM)
	+ default : Chỉ dùng được trong package ( package private)
	+ private : Chỉ dùng được trong lớp.
	+ protected : Chỉ dùng trong package hoặc subclass
	+ public : Dùng được ở mọi nơi
	+ //Note: Không thể khai báo 1 class và interfaces ở mức private hoặc protected.
KEYWORD:
	//this
		+ this. : Dùng để tham chiếu đến biến instance. Tránh nhầm lẫn khi instance với đối số cùng name.
		+ Biến thể của this. là this() <=> this() để truyền đối số với construct tương ứng khi viết construct overload. VI DU: http://codepad.org/gtwtkSnw
		+ this dùng làm tham số để truyền vào phương thức. VD: http://codepad.org/BtT1QHjG
	//final
		+final dùng để chỉ hằng số. Có thể dùng cho class, variables, method
		//Với Biến: Không thể tái cấp phát 
		//Với medthod: Không thể overload
		//Với class: Không thể extend
		//Các biến final (nên) được viết hoa. VD fianl int MAX = 100;
	//instanceof (return: true or false)
		+Dùng để kiểm tra một biến thực thể có phải tạo ra từ class hay không
		Ví dụ: 	String name = "Lee";
			boolean check = name instanceof String;
			System.out.println(check) == true.
	//super
		+ Dùng để truy cập vào method lớp cha từ lớp con VD: https://www.programiz.com/java-programming/method-overriding
Inheritance (5 kiểu Kế thừa)
	+ Single: Lớp B được extends từ lớp A, A->B.
	+ Multilevel: Lớp B extends A, lớp C extends B, A->B->C.
	+ Hierarchical (thứ bậc): Lớp B,C,D,... extends từ lớp A. A->B; A->C; A->D,...
	+ Mutiple: Interface C được extends từ Interface A, Interface B, Interface D,.. A->C, B->C, D->C,...
	+ Hybird: Kết hợp 2 hay nhiều kiểu trên.
	//Java không hỗ trợ Mutiple và Hybird cho kế thừa class, nhưng Interface thì được.
        //Nếu không muốn lớp khác extends từ class đã tạo, thêm từ khoá final (EX: final class Animal{ } )
	>>>Một số lưu ý khi kế thừa:
	+ Các thành phần private của superclass thì lớp con không thể kế thừa
	+ Lớp con có thể kế thừa tất cả thành phần của superclass. Tuy nhiên, Constructors thì không vì nó k phải là một "member" của class
	Constructors của superclass có thể truyền thông qua từ lớp con.
	+ Lớp cha chỉ có duy nhất: Lớp cha có thể có nhiều lớp con. Tuy nhiên, lớp con chỉ có duy nhất lớp cha (Triết lý nhân sinh =)) )
	Trong Java chỉ hỗ trợ kế thừ đa cấp (Mutiple) và kế thừa kết hợp (Hybird) cho Interface.
	+ Trong trường hợp không có lớp cha rõ ràng nào. Thì default superclass được hiểu ngầm là Object class.
Encapsulation (Tính bao đóng)
	+ Tính bao đóng khi có các biến, thuộc tính khai báo kiểu private (Chỉ dùng được trong phạm vi class)
	+ Tính bao đóng dùng các phương thức public set(nhận giá trị) và get() trả về giá trị cho các biến trong Class có dạng private
	>>> Ưu điểm có tính bao đóng:
		+ Ẩn dữ liệu, tăng tính bảo mật: Người dùng chỉ biết truyền và nhận dữ liệu thông qua 2 phương thức get và set, mà không biết trong class đó 
		đang lưu trữ các loại dữ liệu gì.
		+ Tăng tính linh hoạt: Có thể làm cho các biến ở dạng chỉ đọc (Bỏ phương thức set() ) hoặc ở dạng chỉ ghi (Bỏ phương thức get() ). 
		Có thể thay đổi một phần code mà không làm ảnh hưởng đến các phần khác.
		+ Dễ dàng tái sử dụng
		+ Dễ dàng kiểm thử đơn vị (Unit testing)
Overriding và Overloading
	//Overriding
	+ Overriding: Được biết là khi method của subclass (CÙNG TÊN, CÙNG SỐ LƯỢNG THAM SỐ, CÙNG KIỂU TRẢ VỀ)
	với method superclass. Khi object gọi method này, method ở subclass sẽ được thực thi.
	+ Không thể Overriding với một method final hoặc static. (Chương tình báo lỗi)
	+ Chỉ nên Overriding một abstract method với lớp cha.
	//Overloading
		
	
	
	
	
	
	
